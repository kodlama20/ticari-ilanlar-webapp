#!/usr/bin/env bash
set -euo pipefail
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"
VER_FILE="VERSION"
read_version(){ [[ -f "$VER_FILE" ]] && tr -d ' \n' < "$VER_FILE" || echo "0.0.0"; }
write_version(){ echo -n "$1" > "$VER_FILE"; }
bump_semver(){ IFS=. read -r MA MI PA <<<"$1"; case "$2" in major) MA=$((MA+1)); MI=0; PA=0 ;; minor) MI=$((MI+1)); PA=0 ;; patch) PA=$((PA+1)) ;; *) echo "Unknown bump: $2" >&2; exit 1;; esac; echo "${MA}.${MI}.${PA}"; }
ensure_clean_tree(){ if ! git diff --quiet || ! git diff --cached --quiet; then echo "Working tree not clean. Commit or stash first." >&2; exit 1; fi; }
open_pr_for_version(){ local new="$1" branch="release/v${new}"; git switch -c "$branch"; write_version "$new"; git add "$VER_FILE"; git commit -m "chore(release): bump version to v${new}"; git push -u origin "$branch"; gh pr create --title "release: v${new}" --body "Bump version to v${new}.\n\nMerge this, then run: \`tools/release tag\`"; echo "âœ… Opened PR for v${new}. After merge, run: tools/release tag"; }
cmd="${1:-}"
case "$cmd" in
  major|minor|patch) ensure_clean_tree; cur="$(read_version)"; new="$(bump_semver "$cur" "$cmd")"; open_pr_for_version "$new" ;;
  set) ensure_clean_tree; new="${2:?Usage: tools/release set X.Y.Z}"; [[ "$new" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || { echo "Invalid version: $new"; exit 1; }; open_pr_for_version "$new" ;;
  tag) git checkout main; git pull --rebase origin main; ver="$(read_version)"; tag="v${ver}"; git rev-parse "$tag" >/dev/null 2>&1 && { echo "Tag $tag already exists." >&2; exit 1; }; git tag -a "$tag" -m "Release $tag"; git push origin "$tag"; gh release create "$tag" --generate-notes -t "$tag"; echo "ðŸŽ‰ Release $tag created." ;;
  *) cat <<USAGE
Usage:
  tools/release patch|minor|major   # bump version, open PR
  tools/release set X.Y.Z           # set exact version, open PR
  tools/release tag                 # tag current main as v\$(cat VERSION) + create GitHub Release
USAGE
     exit 1 ;;
esac
